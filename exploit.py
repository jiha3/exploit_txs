from phalcon import get_balance_change_from_tx
#from transaction import Transaction
#from account import Account
import utils
import json
import time
import os
import datetime
import requests
import ccxt
from config import PHALCON_CACHE, CASE_CACHE, API_KEYS, REQUEST_URLS, HEADER

#STABLE = ["ether", "weth", "wbnb", "bnb", "usdt", "usdc", "wbtc", "dai", "susd", "bsd-usd","bnb", ]
PEGGED = ["dai", "usdc", "usdt", "usd", "tusd", "ustc", "xrp", "busd", "usdp", "wbnb", "matic", "wmatic", "weth"]
PEGGED_1 = ["dai", "usdc", "usdt", "usd", "busd"]
MAL = ["exploit", "phishing", "hacker"]
whitelist = []
undefined_tokens = list()

COINBASE_KEY = "4SFyRR6d8teWqSsh"
COINBASE_SECRET = "43oyhD6ASbOggXrHA76acdJmzSBGz4FM"

class Exploit:
    def __init__(self, chain, tx_hash):
        self.chain = chain
        self.tx_hash = tx_hash
        #self.exploiters = dict()
        self.exploiters = list()
        #self.name = name
        self.exploits = [self.tx_hash]
        self.loot_dict = dict()
        self.total_loot = dict()
        self.case_cache = dict()
        self.request_url = REQUEST_URLS[self.chain]
        self.api_key = API_KEYS[self.chain]
        self.load_by_cache()
        
        '''
        if not os.path.exists(f"{CASE_CACHE}/{name}_{date}"):
            with open(f"{CASE_CACHE}/{name}_{date}", 'w') as f:
                json.dump(self.case_cache, f)
        else:
            with open(f"{CASE_CACHE}/{name}_{date}", 'w') as f:
                case_cache = json.load(f)
                if self.tx_hash in case_cache['exploit_txs'] : 
                    return 1
                else:
                    self.case_cache['exploit_txs'].append(self.tx_hash)
        '''

    def load_by_cache(self):
        if not os.path.isfile(f"{PHALCON_CACHE}/{self.chain}-{self.tx_hash}"):
            get_balance_change_from_tx(self.chain, self.tx_hash)
        data = utils.load_cache_by_one(self.chain, self.tx_hash)
        self.sender = data['sender']
        self.receiver = data['receiver']
        self.tokens = data['token']
        self.accounts = data['accounts']
        self.changes = data['changes']
        self.blockNumber = data['blockNumber']
        self.timestamp = data['timestamp'] # initial timestamp --> only one
        self.methodId = data['methodId']

    def get_method_id(self):
        params = {
            "module" : "account",
            "action" : "txlist",
            "address" : self.sender,
            "startblock" : self.blockNumber,
            "endblock": self.blockNumber+10000,
            #"page" : 1,
            #"offset" : 100,
            "sort" : "asc",
            "apiKey" : self.api_key
        }
        
        response = requests.post(self.request_url, data = params)
        rs = json.loads(response.text)['result']
        #print(rs)
        for r in rs[1:]:
            if r['methodId'] == self.methodId:
                self.exploits.append(r['hash'])
        print(self.exploits)
            

    def identify_accounts(self):
        # exploiters : [0x1111...11, 0x222...22, 0x33...33]
        #loot_dict :   {'0x1111...11' : [{"0x9f3...ae": 576.0}, "0x29f...fe":22.14], }
        for k, v in self.changes.items():
            # check whether this is a contract or an EOA
            if (k in list(self.accounts.keys()) and not any(mal in self.accounts[k].lower() for mal in MAL)) or k =="0x0000000000000000000000000000000000000000":
                whitelist.append(k)
            else:
                # Real logic
                params = {'module': 'contract', 
                            'action': 'getcontractcreation', 
                            'contractaddresses': k, 
                            'apikey': self.api_key
                            }
                response = json.loads(requests.post(self.request_url, data = params).text)
                #print(response)
                if response['status'] == 0:
                    #print("This is an EOA")
                    info = 'E'
                else:
                    info = 'C'

                # For the case where the address is clarified as an "exploit" something.
                if k in list(self.accounts.keys()) and any(mal in self.accounts[k].lower() for mal in MAL):
                    print(f"Explicit Exploiters : {k}")
                    self.exploiters.append(info)
                    self.loot_dict[k] = self.changes[k]
                
                # For the case where addresses are not declared but seem suspicious.
                elif k not in list(self.accounts.keys()):
                    # For the case where it is not a publicized EOA.
                    if info == 'E':
                        print(f"Account(EOA) : {k} : {v} - Highly Likely Related to Exploits.")
                        self.loot_dict[k] = self.change[k]
                        #self.exploiters[k] = 'E'
                    
                    # For the case where the contract ABI is not open -> Suspicious.
                    else:
                        #print("This is a contract")
                        params = {
                            "module" : "contract",
                            "action" : "getabi",
                            "address" : k,
                            "apiKey" : self.api_key
                            }
                        response = requests.post(self.request_url, data = params)
                        rs = json.loads(response.text)
                        if rs['status'] == '0':
                            # If ABI is not open
                            coinbase_header = HEADER
                            coinbase_header['content-type'] = 'application/x-shockwave-flash'
                            timestamp = int(datetime.datetime.strptime(self.timestamp, "%Y-%m-%dT%H:%M:%S%z").timestamp() * 1000)
                            #exchange =ccxt.coiunb()
                            cost = 0
                            win = 0
                            lose = 0
                            for v_key, v_val in v.items():
                                #try:
                                token_name = self.tokens[v_key]["label"].upper()
                                cost += v_val[1]
                                '''
                                print("Search value of {} at the time {} (coinbase)".format(token_name, timestamp))
                                #response = exchange.fetch_ohlcv (token_name, '1m', timestamp, 1)
                                url = f"https://www.coinbase.com/graphql/query?&operationName=AssetSearchResultsQuery&extensions=%7B%22persistedQuery%22%3A%7B%22version%22%3A1%2C%22sha256Hash%22%3A%22773048a9ecd61850e387dad6a73c1de810fe3a3085d67230ee00584119587514%22%7D%7D&variables=%7B%22searchQuery%22%3A%22{token_name}%22%2C%22first%22%3A50%7D"
                                req = requests.get(url, headers=coinbase_header).json()
                                data = req['data']["viewer"]["searchAssets"]["edges"]
                                for d in data:
                                    asset = d['node']['asset']
                                    if(asset['displaySymbol'] == token_name):
                                        slug = asset['slug']
                                        print(f"##############{slug}")
                                        break
                                price_data = f"https://www.coinbase.com/graphql/query?&operationName=AssetOverviewQuery&extensions=%7B%22persistedQuery%22%3A%7B%22version%22%3A1%2C%22sha256Hash%22%3A%220111bc31a4f7a47c0f535421488ac68733018adcba190cdded57576121a25910%22%7D%7D&variables=%7B%22assetUuid%22%3A%22%22%2C%22assetSlug%22%3A%22{slug}%22%2C%22nativeCurrency%22%3A%22USD%22%2C%22locale%22%3A%22en%22%2C%22skipWrappedEntry%22%3Atrue%2C%22sourcePage%22%3A%22ASSET_PAGE%22%2C%22country%22%3A%22US%22%2C%22chainId%22%3A1%2C%22skipDappWalletExperiment%22%3Afalse%2C%22assetArticlesCount%22%3A20%2C%22skipEth2Announcement%22%3Atrue%2C%22skipAssetPerfTimeRanges%22%3Atrue%2C%22shouldIncludeBalanceSummaryInfo%22%3Atrue%2C%22productKey%22%3A%22SUBSCRIPTION_PRODUCT_COINBASE_PLUS%22%2C%22accountUuid%22%3A%22%22%2C%22assetSymbol%22%3A%22%22%2C%22skipAccountUuid%22%3Atrue%2C%22skipAssetSlug%22%3Afalse%2C%22skipAssetSymbol%22%3Atrue%2C%22skipAssetUuid%22%3Atrue%2C%22includeAutoStakingCheck%22%3Atrue%2C%22targetAssetSlug%22%3A%22%22%2C%22skipTargetAssetSlug%22%3Atrue%7D"
                                #res = requests.get(price_data, headers= coinbase_header).json()
                                #priceForAll = res["data"]["viewer"]["assetBySlug"]["asset"]["priceDataForAll"]["quotes"]
                                #print(priceForAll)
                                #for case in priceForAll:
                                #    if(case["timestamp"])
                                    #cost += response[0][1]*v_val

                                    #print(f"Found Symbol on coinbase, and its cost was {cost}")
                                
                                except:
                                    print(f"Did not found symbol {token_name} in kucoin")
                                    undefined_tokens.append(token_name)
                                    if v_val <0 : lose+=1
                                    else : win +=1
                                    '''
                            # This methodology is a bit intuitional, not verified.
                            # 10 is the number that I chose.
                            if (cost>10):
                                self.loot_dict[k] = self.changes[k]
                                #self.exploiters[k] = 'C'
                                print(f"Contract(ABI is not public) : {k} : {v} - Highly Likely Related to Exploits.")  
                            
                        else:
                            print(f"(PROBABLY) Valid Contract, {k}")
        with open('identify_accounts_test', 'a') as f:
            new_dict=dict()
            new_dict[f"{self.chain}-{self.tx_hash}"] = self.loot_dict
            json.dump(new_dict, f)
    
    def trace_token(self):
        for loot_k, loot_v in self.loot_dict.items():
            for _k, _v in loot_v.items():
                #PEGGED = ["dai", "usdc", "usdt", "usd", "tusd", "ustc", "xrp", "busd", "usdp"]
                if self.tokens[_k]['stable'] == 1 and self.tokens[_k]['label'].lower() in PEGGED: # 추가적인 trace 불필요
                    self.total_loot += _v
                elif self.tokens[_k]['stable'] == 1 and self.tokens[_k]['label'].lower() not in PEGGED: # stable coin은 아닌데 value 측정되어 있는 애들
                    timestamp = int(datetime.datetime.strptime(self.timestamp, "%Y-%m-%dT%H:%M:%S%z").timestamp() * 1000)
                    exchange = ccxt.kucoin()
                    token_name = self.tokens[_k]['label']
                    # get the token value at that time
                    try:
                        response = exchange.fetch_ohlcv(self.tokens[_k]['label'], '1m', timestamp, 1)
                        price = response[0][1]
                        self.total_loot += _v*price
                        print(f"Total loot is : {self.total_loot}")
                    except:
                        print(f"{token_name} is not found on kucoin")
                '''
                elif self.tokens[_k]['stable'] == 0: # 잡토큰
                    # 이것이 문제로다
                    if self.exploiters[_k] == 'C':
                        params = {
                            'module' :'account', 
                            'action' :'tokentx', 
                            'contractaddress' : _k,
                            'startblock' : self.blockNumber,
                            'endblock' : self.blockNumber+ 100000,
                            'sort' : 'asc',
                            'apikey' : self.api_key
                        }
                    response = json.loads(requests.post(self.request_url, data = params).text)
                    if response['status'] == 0:
                        print("Not related to ERC20")
                    else:
                        results = response['result']
                        for result in results:
                            self.trace_one(result)
                '''

if __name__ == "__main__":
    for file in os.listdir(PHALCON_CACHE):
        print(file)
        if '-' in file:
            x = file.split('-')
            chain = x[0]
            hash = x[1]
            if chain in ['bsc', 'eth', 'ftm', 'polygon']:
            # Optimism : error-prone / Avalanche : could not find any valid API     
                test_tx = Exploit(chain, hash)
                #test_tx.get_method_id()
                test_tx.identify_accounts() 
                time.sleep(5)
    print(undefined_tokens)